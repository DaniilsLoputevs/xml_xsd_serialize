# xml_xsd_serialize

## Тестовое задание для Цифроматика.
Постановка:

Есть модель Сотрудник (ФИО, дата рождения) - Организация (Наименование, Дата создания, Статус). Отношение многие-ко-многим.
Статус - Открыта, Закрыта

Задача:

1. Необходимо выполнить сериализацию в xml массива организаций с перечислением её участников.
2. Необходимо выполнить десериализацию файла, вывести в консоль только открытые организации.
3. Необходимо сгенерировать xsd файлы для модели.

Ожидаемый результат:
Архив или ссылка на гитхаб с рабочими исходниками для решения задач и xsd схемой.
* Опционально описать ход решения и причины выбора того или иного инструмента


Просим предоставить ответы на вопросы и тестовое задание:
1. Что означает буква L из SOLID
   * L - Принцип подстановки Лисков - Наследник не должен ломать контракты Родителя иначе, в месте использования Родителя программист увидит Сюрприз и будет матюгатся.
   * Хороший пример это java.util.List + java.util.List.of() который возвращает Неизменяемый Лист. Заменил так ArrayList, на List.of() и отправил в Прод, а через месяц, коллега вызвал метод add(E element) и начала матюгатся т.к. точно помнит, что делал там ArrayList, а сейчас видит UnsupportedException. :D
   * Ещё пример с java.util.Data + java.sql.Date(наследник от java.util.Data) - последний нарушает контракт метода Date.toInstant(), при вызове выбрасывает UnsupportedOperationException. Из-за этого есть сложности в конвертации этого объекта в другие типы хранения времени(LocalDate, Calendar и т.д.). В доке/контракте по java.util.Data#toInstant() не сказано, что метод может бросать такие ошибки. 
2. В чём разница между обёрткой и адаптером. А между фабрикой и билдером?
   * Обертка(Wrapper) - добавляет новую функциональность к существующему классу, не изменяя его интерфейса/контракт. Пример: java.lang.[Integer, Double, Boolean]
   * Адаптер(Adapter) - Мост между 2 API, что потенциально не знают друг о друге и не имеют готового решения из коробки.  Пример: java.util.Arrays#asList()
   * Фабрика(Factory) - предоставляет интерфейс для создания объектов различных типов без явного указания их конкретных классов. Пример: java.util.Calendar & [java.util.GregorianCalendar, java.util.JapaneseImperialCalendar]
   * Билдер(Builder) - пошаговое создания сложных объектов с гибкими параметрами конфигурации. Пример: java.lang.StringBuilder & [append(), insert(), delete()]
3. Какую проблему решает полиморфизм?
   * Смысл полиморфизма: Дать возможность писать более гибкий, настраиваемый, расширяемый, универсальный и обратно совместимый код.
   * + Многие паттерны проектирования основаны это на механизме полиморфизма
4. В чём недостатки ORM? Как их решать\избегать?
   * Потеря производительности на большом кол-во меппинга между сущностями.
     * Выгружать только требуемые поля(Projection).
     * Кеширование, если оно возможно в данной ситуации
   * В случаи ORG framework сломался и нужно чинить - бывает очень не просто понят что-где-почему-когда пошло нетак
5. Когда применяется денормализация? Когда не следует добавлять индекс?
   * Денормализация - коротко - больше дублирования данных, меньше ссылок на данные(join и sub-select)
     * Улучшение производительности - чем меньше таблиц затронуто запросом, тем меньше действий нужно БД для корректной обработки запроса(меньше локов на таблицы/записи, меньше IO операция и т.д.) 
     * Упрощение разработки - меньше связанность Сущностей(проще читать иерархию бизнес моделей) и меньше использования API по соединения Сущностей(в Hibernite - магия, что не видна программисту, в native sql - меньше склеек таблиц) 
   * Когда не следует добавлять индекс - коротко - жертвую местом на диске, ради большей производительности select запросов
     * Редкие операции поиска - мало смысла в оптимизации редкого кейса
     * Частые операции записи - каждая операция записи обременена доп. работой по актуализации Индекса, что её замедляет. 
6. Какая сложная вставки в дерево? Какая сложность бинарного поиска?
   * Вставка в Красно-Чёрное всегда: O(log n)
   * Сложность бинарного поиска: O(log n)
     * Требуется отсортированная структура для бинарного поиска. Обычно сортировка в java имеет сложность: O(n log n)
7. В чём недостатки аннотаций и рефлексии?
   * Аннотации
     * compile source - что бы, внести минимальные изменения нужно перекомпилить код, что плохо в сравнении с конфиг файлами, где обычно, будет достаточно перезапустить приложение.
     * Ограниченная расширяемость - 
       * Нет Иерархий аннотаций - в Спринге ребята сами решали этот вопрос, но всё равно, это больно.
       * Нет Возможности писать Кастомные типы в свойствах/полях аннотации, только Примитивы, Массивы и Class<?>
   * Рефлекция
     * Сложность чтения и понимания кода - Много магии которая не видна, может устроить добротное сношение мозга программиста с кодом на рефлексии
     * Ухудшение производительности - Рефлексия это Возможности, а не про Быстро...
     * Потеря статической типизации - Рефлекцися это runtime + Object object - легко можно отстрелить конечности и не только себе и не сразу.   
8. Генерировали ли классы из xsd схем?
   * По ходу выполнения этого задания, реализовал генерация XSD Schema из Java Class с помощью JAXB.
   * Реально разобраться в Обратном процессе за день.  
9. Как напишите интеграционный тест?
   * Интеграционное тестирование – это тип тестирования, при котором программные модули объединяются логически и тестируются как группа.
   * Подниму контекст и протестирую полную цепочку взаимодействия.